<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book id="UTF-8">
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="bookinfo.xml"/>
                 <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="acknowledgements.xml"/>
  <preface>
    <title>Preface</title>
    <para>The preface is any content before a wiki section.</para>
  </preface>
  <chapter>
    <title>Introduction</title>
    <para>DaoJones is designed for accessing databases by mapping Java objects to database entities. Those databases must not be relational.</para>
    <section>
      <title>History</title>
      <para>The project was initially founded in 2007 as part of the <ulink url="http://www.ars.de/">ARS Website</ulink> project. The main purpose at that time was to encapsulate accesses to the website database - which is a Notes database - in a separate layer to make the business entities independent from the Notes Java API. This allowed to implement thread safety at a central position and to make this available for the whole application.</para>
      <para>By now, DaoJones is used by multiple ARS-internal projects (e.g. the  <emphasis role="italic">Unterlagengenerierung</emphasis> ) and by currently a single customer project too.</para>
      <para>The name <emphasis role="italic">DaoJones</emphasis> is derived from the abbreviation <emphasis role="italic">DAO</emphasis>, which is used for <emphasis role="italic">Data Access Objects</emphasis>, a design pattern used for persistence implementations. The term is not used anymore, it was replaced by a simple POJO, briefly called <emphasis role="italic">bean</emphasis>.</para>
      <note>
        <para>Although it allows to use different database drivers, currently there is only one driver implementation to access Notes databases. Further drivers must yet be implemented.</para>
      </note>
    </section>
    <section>
      <title>Intention</title>
      <para>The framework is intented to be used by Java applications to map business entities to databases, no matter what kind of database (relational, document-based, object-based, file-based) is used at runtime. The database can be replaced without any changes within the application code. The developer can handle the concepts and terms of DaoJones and does not have to get familiar with database-specific concepts and terms.</para>
    </section>
  </chapter>
  <chapter>
    <title>Concepts</title>
    <para>This chapter names and describes basic concepts and terms that should be known to understand the functionality of the framework.</para>
    <section>
      <title>Bean Mapping</title>
      <para>The most important concept is the mapping of beans to an artifact within the database. The following graphic shows the mapping between a Java bean and a Notes document. The Java bean has a class that is mapping to the <emphasis role="italic">Form</emphasis> field of the Notes document. The fields of the class are mapped to further fields of the Notes document. This mapping can be customized by annotations, an external XML file or programmatically at runtime using the <emphasis role="italic">Bean Model API</emphasis>. See chapter <link linkend="concepts_bean_model">Bean Model</link> for detailed information.</para>
      <para>
        <figure>
          <title>The bean mapping to a Notes document</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" fileref="images/content/concepts/mapping.png" format="PNG" width="10mm"/>
            </imageobject>
            <imageobject role="html">
              <imagedata align="center" fileref="images/content/concepts/mapping.png" format="PNG" scale="100"/>
            </imageobject>
          </mediaobject>
        </figure>
      </para>
      <para>It is also possible to map a bean to a view, i.e. a selection of entities based on a query and a provision of columns based on single fields or on calculated values. Views can provide sorting and categorizing entries.</para>
      <para>
        <figure>
          <title>The bean mapping to a Notes view</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" fileref="images/content/concepts/mappingView.png" format="PNG" width="10mm"/>
            </imageobject>
            <imageobject role="html">
              <imagedata align="center" fileref="images/content/concepts/mappingView.png" format="PNG" scale="100"/>
            </imageobject>
          </mediaobject>
        </figure>
      </para>
      <caution>
        <para>Please be aware that view columns with calculated values can only be mapped to read-only fields and are therefore cannot be used for updates.</para>
      </caution>
    </section>
    <section>
      <title>Datatype Mapping</title>
      <para>The mapping of Java and database fields or columns is not limited to strings. The following types can be used as Java field type:</para>
      <itemizedlist>
        <listitem>
          <para>Primitive types and their wrapper classes</para>
        </listitem>
        <listitem>
          <para>
            <code>java.lang.String</code>
          </para>
        </listitem>
        <listitem>
          <para>
            <code>java.util.Date</code>
          </para>
        </listitem>
        <listitem>
          <para>One-dimensional Arrays of these types</para>
        </listitem>
        <listitem>
          <para>
            <code>de.ars.daojones.runtime.beans.fields.Resource</code> (for BLOBs, CLOBs, Attachments...) - see Section <link linkend="database_access_advanced_attachments">Attachments</link>
          </para>
        </listitem>
      </itemizedlist>
      <para>  - "Bean", Mapping (Field and DataSource/TABLE/VIEW, Supported Types (inkl. Arrays, Resource, ...))   - Models (Connection-, Bean-, ConnectionFactory-, CacheFactory-, Application-)   - DaoJonesContext, -Factory und -Config</para>
      <para>  </para>
    </section>
    <section id="concepts_bean_model">
      <title>Bean Model </title>
    </section>
  </chapter>
  <chapter>
    <title>Database Access (Basics)</title>
    <para>TODO</para>
    <section>
      <title>A simple example</title>
      <para>
        <example>
          <title>A first example code</title>
          <programlistingco>
            <areaspec units="linecolumn">
              <areaset coords="" id="callout-0_">
                <area coords="12 5" id="callout-0__" linkends="callout-0"/>
                <area coords="18 7" id="callout-1__" linkends="callout-1"/>
              </areaset>
            </areaspec>
            <programlisting language="java"><![CDATA[  public void demo1() throws DataAccessException,
  ConfigurationException {
    final DaoJonesContextFactory dcf = new DaoJonesContextFactory();
    dcf.setBeanConfigurations( new ApplicationBeanConfigurationProvider(
            DaoJonesDemo.APP,
            new AnnotationBeanConfigurationProvider() ) );
    dcf.setConnectionConfigurations( new ApplicationConnectionConfigurationProvider(
            DaoJonesDemo.APP,
            new XmlConnectionConfigurationProvider(
                    DaoJonesDemo.class
                    .getResource( "daojones-connections.xml" ) ) ) );
     
    final DaoJonesContext ctx = dcf.createContext();
    try {
      final ConnectionProvider cp = ctx
              .getApplication( DaoJonesDemo.APP );
      final Connection<Memo> con = cp.getConnection( Memo.class );
       
      try {
        // SearchCriteria etwas anders?
        final SearchResult<Memo> memos = con.findAll( Query.create()
                .only( 2 ) );
        for ( final Memo memo : memos ) {
          // Iterate through the search results
          // (Streamed results)

        }
      } finally {
        con.close();
      }
    } finally {
      ctx.close();
    }

    Query.create().only(
            property( "receiver" ).isEmpty().or().property( "sender" )
            .isEmpty() );
    Query.create().only( not( TRUE() ).and().TRUE().or().FALSE() );
    Query.create()
    .only( property( "title" ).isEmpty().and().field( "text" )
            .asString().startsWith( "Hallo" ) ).only( 10 );
    Query.create().only(
            property( "title" ).isEmpty().or().asString()
            .contains( "Tagebuch" ).and().startsWith( "Mein" )
            .or().endsWith( "Dein" ) );
    Query.create().only(
            property( "authors" )
            .asCollectionOf( String.class )
            .containsAllOf( "Ralf Zahn", "Michael Mueller" )
            .or()
            .containsOneOf( "Stefan Schaeffer",
                    "Domink Ebert" ) );

  }]]></programlisting>
            <calloutlist>
              <callout arearefs="callout-0_">
                <para>Compatible with try-with-resources (since Java 7)</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>
      </para>
    </section>
  </chapter>
  <chapter>
    <title>Database Access (Advanced)</title>
    <para>TODO</para>
    <section id="database_access_advanced_attachments">
      <title>Attachments </title>
    </section>
  </chapter>
  <chapter>
    <title>JUnit Test Support</title>
    <para>TODO</para>
  </chapter>
  <chapter>
    <title>Integration into Java Environments</title>
    <para>TODO</para>
  </chapter>
  <chapter>
    <title>Perspectives</title>
    <para>TODO</para>
  </chapter>
</book>
